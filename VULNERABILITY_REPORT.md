# Vulnerability & Logic Bug Report

This report details security loopholes and logic flaws found during the code audit.

## Part 1: Initial Findings (app.py)

### 1. Plan Type Manipulation in Subscription Creation

*   **Location:** `app.py`, in the `create_razorpay_subscription()` function.
*   **Vulnerability:** The `plan_type` received from the user is used to construct an environment variable name (e.g., `RAZORPAY_PLAN_ID_PERSONAL_INR`) without validation. A malicious user could send a custom `plan_type` string, potentially causing the application to read an unintended environment variable.
*   **Recommendation:** Add a validation step to ensure `plan_type` is one of the expected values (`'personal'` or `'creator'`) before it's used.

### 2. Code Duplication and Missing Validation in Admin Payouts

*   **Location:** `app.py`, in the `initiate_razorpay_payout()` function.
*   **Logic Bug:** The function contains a large, duplicated block of validation code.
*   **Vulnerability:** The `amount` for the payout is not checked to ensure it is a positive number.
*   **Recommendation:** Refactor the function to remove the duplicated code and add a validation check to ensure the payout amount is greater than zero.

---

## Part 2: Creator Earnings & Payout System (utils/db_utils.py)

### 1. Critical: Race Condition in Payout Requests

*   **Vulnerability:** The `create_payout_request` function in `utils/db_utils.py` is vulnerable to a "Time-of-check to time-of-use" (TOCTOU) race condition. It checks the balance and then creates the payout in two separate, non-atomic steps.
*   **Impact:** A user can create payout requests that exceed their actual withdrawable balance, leading to financial loss.
*   **Proposed Solution:** Use a Supabase RPC function (stored procedure) to perform the balance check and the payout creation within a single atomic transaction.

    **SQL for `create_payout_request_atomic` function:**
    ```sql
    CREATE OR REPLACE FUNCTION create_payout_request_atomic(
        p_creator_id UUID,
        p_amount_usd NUMERIC,
        p_payout_details JSONB
    )
    RETURNS TABLE(id BIGINT, creator_id UUID, amount_usd NUMERIC, status TEXT, requested_at TIMESTAMPTZ) AS $$
    DECLARE
        v_total_earned NUMERIC;
        v_pending_payouts NUMERIC;
        v_total_paid NUMERIC;
        v_withdrawable_balance NUMERIC;
        new_payout RECORD;
    BEGIN
        -- Lock the creator's profile row to prevent concurrent payout requests for the same user
        PERFORM * FROM profiles WHERE profiles.id = p_creator_id FOR UPDATE;

        -- Calculate total earnings
        SELECT COALESCE(SUM(ce.amount_usd), 0) INTO v_total_earned
        FROM creator_earnings ce WHERE ce.creator_id = p_creator_id;

        -- Calculate total pending and paid payouts
        SELECT
            COALESCE(SUM(cp.amount_usd) FILTER (WHERE cp.status IN ('pending', 'processing')), 0),
            COALESCE(SUM(cp.amount_usd) FILTER (WHERE cp.status = 'paid'), 0)
        INTO v_pending_payouts, v_total_paid
        FROM creator_payouts cp WHERE cp.creator_id = p_creator_id;

        v_withdrawable_balance := v_total_earned - v_pending_payouts - v_total_paid;

        -- Check if the balance is sufficient
        IF p_amount_usd > v_withdrawable_balance THEN
            RAISE EXCEPTION 'Withdrawal amount (USD %) exceeds available balance (USD %)', p_amount_usd, v_withdrawable_balance;
        END IF;

        -- Insert the new payout request
        INSERT INTO creator_payouts (creator_id, amount_usd, status, payout_destination_details)
        VALUES (p_creator_id, p_amount_usd, 'pending', p_payout_details)
        RETURNING * INTO new_payout;

        RETURN QUERY SELECT new_payout.id, new_payout.creator_id, new_payout.amount_usd, new_payout.status, new_payout.requested_at;

    END;
    $$ LANGUAGE plpgsql;
    ```

### 2. High: No Handling for Refunds or Cancellations

*   **Vulnerability:** The system records a creator's commission but has no process to revoke that commission if the user gets a refund.
*   **Impact:** The platform will pay commissions on revenue that it has to return, leading to direct financial loss.
*   **Proposed Solution:** Create a new webhook to listen for refund events. This webhook should call a new `revoke_creator_earning` function that creates a *negative* entry in the `creator_earnings` table to offset the original commission and maintain a clear audit trail.

### 3. Medium: No Payout Clearing Period

*   **Vulnerability:** Earnings are available for withdrawal immediately, which is risky.
*   **Impact:** Exacerbates the refund vulnerability, as a creator can be paid out for a transaction that has not yet cleared or is still within the refund window.
*   **Proposed Solution:** Modify `get_creator_balance_and_history` to only include earnings that are older than a set clearing period (e.g., 30 days). This requires adding a `created_at` timestamp to the `creator_earnings` table if it doesn't exist.

### 4. Low: Inaccurate MRR Calculation

*   **Vulnerability:** The MRR calculation in `get_creator_dashboard_stats` does not account for whether a subscription has been cancelled and is merely waiting to expire.
*   **Impact:** Shows inflated and potentially misleading MRR figures to creators.
*   **Proposed Solution:** Modify the function to join with the `razorpay_subscriptions` table (or equivalent) and filter for subscriptions with an `active` status.
